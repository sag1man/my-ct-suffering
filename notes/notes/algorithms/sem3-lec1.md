# DFS, TopSort and SCC
---

[[index|Конспекты]] / [[notes/algorithms/index|Алгоритмы и Структуры Данных]] / [[notes/algorithms/sem3-lec1|Лекция 1 - DFS, TopSort и SCC]]

--- 

## Графы
##### Обозначения:
-  $n$ - число вершин, $m$ - число рёбер
- Граф может быть **ориентированным** или **неориентированным**

### Как хранить граф
##### Матрица смежности $n \times n$
- Ячейка $\mathcal (i, j) = 1$, если есть ребро $\mathcal i \to j$, иначе $0$
- Память: $\mathcal O(n^2)$
- Проверка ребра: $\mathcal O(1)$
- Перебор соседей вершины: $\mathcal O(n)$ на вершину

##### Списки смежности
- Для каждой вершины храним список её соседей
- Память: $\mathcal O(n + m)$
- Перебор всех рёбер/соседей: $\mathcal O(n + m)$

---
## DFS (Поиск в глубину)
##### Идея алгоритма
- Выберем стартовую вершину и будем рекурсивно спускаться, пока есть не посещённые дети, когда их нет - поднимаемся.

**Время работы:** $\mathcal O(n + m)$
``` py
dfs(v):
	visited[d] = true
	for (v, u) in E:
		if (!visited[u]):
			dfs(u)
```

### Компоненты связности (неор. граф)
##### Определение
 - **Компонента связности** - максимальное множество вершин, между любыми двумя из которых существует путь.

##### Утверждения
 - Запуская DFS из какой-то вершины, мы получим всю компоненту связности, в которой он находится (исходя из того что мы посещаем всех не посещенных соседей). 
 - Таким образом, запуская DFS из ещё не посещенных вершин, можно выделить все компоненты в графе (перебираем компоненты пока есть невыделенные).

---
## Поиск цикла в графе
### Неориентированный граф
Поиск цикла можно сделать просто посмотрев по каким ребрам прошел DFS.

##### Определения
- **Древесное ребро** - ребро по которому DFS успешно спустился.
- **Обратное ребро** - ребро, по которому DFS не переходит, так как оно соединяет уже посещенные вершины.

##### Утверждения
 - Обратное ребро всегда соединяет потомка и предка (иначе бы мы попали в потомка раньше).
 - Цикл есть только тогда, когда есть обратные ребра (потому что мы уже были в обоих вершинах, следовательно между ними есть путь).
 - Любой цикл представим как XOR (линейная комбинация) элементарных циклов.

### Ориентированный граф 
Опять запускаем DFS. Снова можем построить дерево из того, как он отработает. 

##### Определения
 - **Древесное ребро** - ребро по которому DFS успешно спустился.
 - **Обратное ребро** - ребро, по которому DFS не переходит, так как оно соединяет уже посещенные вершины (из потомка в предка)
 - **Прямое ребро** - как обратное, но ведет из предка в потомка (как бы со направлено с древесным)
 - **Перекрестное ребро** - ребро не между предком и потомком. 

##### Утверждение
 - Цикл возможен только когда есть обратное ребро (Доказательство очевидно)

##### Раскраска
Для классификации ребер удобно использовать раскраску в 3 цвета:
- 0 - вершина не посещена (Перейдя в такую вершину, ребро было древесным)
- 1 - вошли в неё но не вышли (Перейдя в такую вершину, ребро было обратным)
- 2 - вошли и вышли (Перейдя в такую вершину, ребро было прямым или перекрестным)

---
## Топологическая сортировка (TopSort)
##### Определение
- **TopSort** -  Упорядочивание вершин так, чтобы каждое ребро шло из более ранней вершины в более позднюю.

##### Утверждение
- TopSort возможен **только** для ацикличных ориентированных графов (DAG).

### Через DFS
Обойдем граф с помощью DFS и для каждой вершины посчитаем время входа ($time_{in}$) и время выхода ($time_{out}$). 

##### Утверждение
 - Если мы посмотрим на ребро $u \rightarrow v$, то заметим что $time_{out}(u) > time_{out}(v)$.
 - Рассмотрим 2 случая:
 	1. $time_{in}(u) < time_{in}(v)$: ребро будет либо древесным, либо прямым.
 	2. $time_{in}(u) > time_{in}(v)$ - ребро не может быть обратным (невозможно из-за ацикличности), остается только перекрёстное.

Так как $time_{out}(u) > time_{out}(v)$, мы можем просто отсортировать вершины по $time_{out}$ и тогда получим TopSort. Модифицировав DFS алгоритм, встроим сортировку в него и получим асимптотику $\mathcal O(n + m)$.

---
## Компоненты сильной связности (SCC)
##### Определения
- Отношение сильной связности - $u$ и $v$ сильно связаны если существуют пути $u \leadsto v$ и $v \leadsto u$.
- Компонента сильной связности - множество вершин, где для каждой пары верно отношение сильной связности.
 - Конденсация графа - это когда мы сжимаем все целые компоненты до вершин, сохраняя ребра между ними (по факту позволяет нам свести граф к ацикличному).

### Алгоритм Косарайю
##### Идея алгоритма
- Обрабатывать КСС в порядке убывания максимального $time_{out}$ по их вершинам.

##### Доказательство
Пусть для компоненты сильной связности $c$:
$$
time_{out}(c_1) = max_{v∈c_1} (time_{out}(v))
$$ 

1. На исходном графе выполнить полный DFS и записывать вершины по моменту выхода
2. Начнем с вершины из первой КСС ($c_1$), ее найти просто - у нее самый большой $time_{out}$, пусть она будет $v_1$. 
3. Нам интересно найти все вершины, достижимые из $v_1$, и из которых можно вернуться в $v_1$ (это и будет первой КСС) 
4. Просто запустим DFS из $v_1$ на графе с перевернутыми ребрами, тогда обойдем только $c_1$ (это работает, потому что $c_1$ была первой в top sort), пометим их как посещенные. 
5. Теперь хотим выделить $с_2$, для этого опять найдем вершину с максимальным $time_{out}$ кроме уже посещенных, и повторим всё как при поиске $c_1$.
6. Повторять пока не закончим)

##### Пояснение:
- Это работает потому что мы можем попаcть либо в текущую компоненту, либо предыдущую, которую мы уже выделили и отметили посещенной.

**Время работы:** $\mathcal O(n + m)$


