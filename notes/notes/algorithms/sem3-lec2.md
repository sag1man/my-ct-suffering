# Bridges and Articulation Points
---

[[/index|Конспекты]] / [[/notes/algorithms/index|Алгоритмы и Структуры Данных]] / [[/notes/algorithms/sem3-lec2|Лекция 2 - Bridges and Articulation Points]]

---
## Мосты (Bridges)
##### Определение
- **Мост**: ребро в графе, удаление которого увеличивает число компонент (иными словами, мост не входит ни в один цикл). 

### Как искать мосты
##### Идея
Запустим DFS на дереве, найдем древесные и обратные ребра:
- Мостом может быть только древесное ребро (обратное ребро по определению образует цикл)
- Если мы подозреваем ребро, в том что оно мост, надо проверить что нету параллельных обратных ребер

##### Алгоритм
- Сделаем динамичку, пусть $d[v]$ - глубина $v$, а $up[v]$ - минимальная глубина на которую можно подняться из поддерева $v$ (если из поддерева $v$ ведут обратные ребра, мы хотим взять глубину того, что ведет выше всех)

``` py
dfs(v, parent, depth) {
	visited[v] = true
	d[v] = depth
	up[v] = depth
	for to in g[v]:
		if (to == p):
			continue
		if (!visited[to]):
			# Значит что ребро (v, to) - древесное
			dfs(to, v, depth + 1)
			if (up[to] > d[v]):
				# Если выполнено, то ребро (v, to) - мост
			up[v] = min(up[v], up[to])
		else:
			# Значит что ребро (v, to) - обратное
			up[v] = min(up[v], d[to])
}
```
(Код даже +- рабочий, но если есть кратные ребра, то надо поаккуратнее)
 
### Компонента реберной двусвязности 
##### Определение 
- **Компонента реберной двусвязности** — это подграф графа, в которой для любых двух вершин существуют как минимум два реберно-непересекающихся пути, их соединяющих (или же если проще, то это связный граф, в котором любые две вершины лежат на рёберно простом цикле).

##### Утверждения
- Чтобы выделить компоненты реберной двусвязности, найдем все мосты, вырежем их, и тогда все компоненты графа будут реберно двусвязными.
- На выделенных компонентах (вернув мосты) можно сделать конденсацию, такая конденсация всегда будет деревом.

---
## Точки сочленения (Articulation Points/Cut Vertices)
##### Определение
- **Точка сочленения**:  вершина в графе, удаление которой также приводит к увеличению числа компонент.

### Как искать точки сочленения 
(Идея глобально почти такая же как и с мостами)

##### Идея
Посмотрим на вершину $v$ в графе, проверим что $v$ - т.с. (при удалении $v$ граф распадается на компоненты). 
- Если у всех поддеревьев детей $v$ есть обратные ребра в предков $v$, то $v$ - не т.с. 
- Если есть хоть один ребенок, в чьем поддереве нету обратного ребра наверх, то $v$ - т.с. 

##### Алгоритм
Почти не нужно менять алгоритм для мостов, просто меняем один `if`
``` py
if (up[to] >= d[v] && v in not root) 
	# Если выполнено, то вершина v - точка сочленения
	# Но надо отдельно проверять корень :(
```
Просто ищем хоть одного сына $v$, у которого есть ребро ведущее строго выше $v$, тогда 

### Компонента вершинной двусвязности 
##### Определение
**Компоненты вершинной двусвязности** - это подграфы неориентированного графа, в которых удаление любой вершины не нарушает связность оставшегося подграфа (другими словами, это связные подграфы, в которых любая вершина не является точкой сочленения).

##### Идея
Так легко, как с мостами не получится - надо страдать(

##### Алгоритм
1. Запустим DFS, который будет ходить по ребрам и хранить в стеке все ребра которые посетил (и обратные). 
2. В идем по графу, до момента когда мы вдруг поняли, что поднялись обратно в вершину $v$ из вершины $u$, и $v$ это точка сочленения (см прошлый алгоритм). 
3. Тогда начинаем раскрутку стека пока не дойдем по ребра $(v \to u)$ - мы выделили компоненту, удаляем её из стека. 
4. Последнее состояние, которое осталось после выхода из DFS - последняя компонента

### Block-Cut Tree
##### Задача
 - Найти все вершины через которые пройдет любой путь из s в t (ну и вообще разные алгоритме на дереве можно тогда использовать)

##### Идея
Построим двудольный граф, в одной доле будут компоненты вершинной двусвязности, а в другой точки сочленения. Соединим точки сочленения с компонентами так, как было в изначальном графе.

##### Утверждение
- Получится дерево - циклов не будет (потому что если есть цикл через точку сочленения $c$, то при удалении $c$, у нас останется пусть из одной компоненты в другую, следовательно $c$ не было т.с. $\to$ противоречие).