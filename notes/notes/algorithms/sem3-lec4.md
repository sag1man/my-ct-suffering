
--- 

[[index|Конспекты]] / [[notes/algorithms/index|Алгоритмы и Структуры Данных]] / РАЗДЕЛ НЕ ГОТОВ

---
### Алгоритм Флойда-Уоршелла
Делаем динамичку

$d[k][u][v]$ - длинна кратчайшего пути $u \to v$ (все промежуточные вершины с номерами <= k)

$d[0][u][v] =$
- $0$, $u=v$
- $w(u,v)$, $(u,v) \in E$
- $+\infinity$, иначе

``` py
for k = 1, ..., n:
	for u = 1, ..., n:
		for v = 1, ..., n:
			d[k][u][v] = min(d[k - 1][u][v],
						     d[k - 1][u][k], d[k - 1][u][v])
```

Можно заметить что можно просто убрать первую размерность, и всё будет работать (время всё ещё $O(n^3)$, память теперь $O(n^2)$)

### Алгоритм джонсона
Поменяем веса ребер так, чтобы понятие кротчайшего пути не помется, но станут неотрицательными, после чего запустим деикстру

Пусть $fi(v)$ - потенциал вершины v
w(u, v) - изначальный вес ребра (u, v)
w'(u, v) - новый вес ребра (u, v)
$$
w'(u, v) = w(u, v) + fi(u) - fi(w)
$$

Лемма: 
- P_1 и P_2 пути u \to v
- w(P_1) < w(P_2)
Тогда:
- w'(P_1) < w'(P_2)

$$
w(P) = \sum{w(u_i, u_{i + 1})}

P = \{ (u_1, u_2), (u_2, u_3), ..., (u_{k-1}, u_k), \}

w'(P) = ... = w(P) + fi(u_1) - fi(u_k)
$$

Теорема:
В графе нет отрицательных циклов $<=>$  $\exists fi: \any(u, v) \in E w'(u, v) <= 0$

Рассмотрим отрицательный цикл C (u_1, u_2, ..., u_k, u_1): 
w'(u_1, u_2) + w'(u_2, u_3), ..., w'(u_k, u_1) = 
= w(u_1, u_2) + w(u_2, u_3), ..., w(u_k, u_1) + fi(u_1) - fi(u_1) =  
= w(u_1, u_2) + w(u_2, u_3), ..., w(u_k, u_1) >= 0


fi(v) = dist(s,v)
w'(u, v) = w(u, v) + fi(u) - fi(v) = w(u, v) + dist(s, u) - dist(s, v) >= 0
w(u, v) + dist(s, u) >= dist(s, v)

## Оффтоп (вернемся в DFS)
### Эйлеров цикл
Пытаемся аккуратно ходить по ребрам, если пришли в начало, возвращемся щапомниая

``` py
euler(v, p):
	while (g[v].sive() > 0):
		u = g[v].pop()
		euler(u, v)
	ans.push(v)
```
Получили обратный список вершин, развернем его. Можно и на неориентированном, но надо делать аккуратно.

### Эйлеров путь
Если в графе нету цикла, то алгоритм похожий, но надо запустить из правильной вершины, из той, с которой мы начинаем