# MST
## Минимальное остовное дерево (MST) 
Задача следующая: пусть есть неориентированный граф и у каждого ребра есть вес. Пусть граф связыный. 
Мы хотим выбрать некоторый набор ребер, чтобы у нас получилось дерево, притом мы хотим чтобы сумма ребер была минимальной.

### Лемма о безопасном ребре
Пусть у нас есть какой-то граф, в нем есть некоторое MST. 
Возьмем наш MST, вырежем одно ребро, и полученные две компоненты (они очевидно будут деревьями) назовем разрезом.
Для любого разреза верно, что если между двумя долями разреза в изначальном дереве больше чем одно ребро, то в наш конечный MST попадет самое легкое по весу. Иначе можно заметить очевидное противоречие определению MST (если будет более легкое ребро, то MST было бы с ним)

### Алгоритм Прима
Идея в том, чтобы итеративно строить MST, начнем с какой-нибудь вершины $v_1$. 

Посмотрим на разрез, где первой копоненте будет наша $v_1$, а во второй - все остальные. Тогда по лемме возьмем самое дешевое ребро, допустим оно будет до вершины $v_4$, добавим его в ответ. 
Снова берем разрез, теперь в первой компоненте вершины $v_1$ и $v_4$, во второй - все остальные, снова возьмем самое дешевое ребро между компонентами и тд.

Реализация:
Давайте поддерживать некоторые метрики:
- `used[v]` - добавлено ли `v` в остов
- `min_e[v]` - вес минимального ребра из остова в `v`

```py
# Инициализация
min_e[0] = 0
min_e[i] = inf
# Перебор
for t = 0 ... (n - 2):
	v = -1
	for i = 0 ... (n - 1):
		if (!used[i] && (v == -1 || min_e[i] < min_e[v])):
			v = i
	used[v] = true
	for (v, u) in E:
		min_e[u] = min(min_e[u], w(u, v))
```

Сложность O(n^2 + m)

Можно оптимизировать поиск минимума, тогда будет O(m + n * log(n))

### Алгоритм Крускала
Возьмем все ребра, и отсортируем по неубыванию, будем по ним бежать и пытаться их добавить в ответ, проверяя не создадим ли мы этим добавлением цикл. Просто при попытке добавить ребро будем проверять что они в разных компонентах связности.

```py
for (u, v) in sorted_edges:
	if get(u) != get(v):
		unite(u, v)
```

Сложность: 
Отсортируем за o(m * log(m))
Пройдемся по ребрам за O(m * \alpha(n))

Проблема с памятью, надо хранить все ребра(

### Алгоритм Борувки
$\begin{aligned} P(C_n, x) & = P(C_n \setminus e, x) - P(C_n / e, x) \ & = P(T_n, x) - P(C_{n-1}, x) \ & = x(x-1)^{n-1} - (x-1)^{n-1} + (-1)^{n-1}(x-1) \end{aligned}$