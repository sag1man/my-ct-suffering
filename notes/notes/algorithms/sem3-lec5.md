## MST
Картинка ()

Лемма о безопасном ребре.
Пусть у нас есть граф, разрез графа - 2 множества вершин и ребер, каждая из них - связная компонента. Для любого разреза 
В минимальном остовном дереве любой разрез пересекается ребром с минимальным весом.

Алгоритм Прима
Будем постепенно строить минимальное остовное дерево. Возьмем разрез из первой вершины и всех оcтальных, посмотрим на ребра и возьмем минимальное, оно войдет в мин остов. Перенемем новую вершину в первую долю разреза, теперь у на 2 вершины, опять возьмем минимальное, получили минимальное остовное.

Скорость низкая O(nm)


used[v] - добавлена ли вершина
min_e[v] - вес \min ребра из остова в v

Если сможем поддерживать эти массивчики, получим O(n^2 + m)

```py
for t = 0, ..., (n - 2):
	v = -1
	for i = 0, ..., (n - 1):
		if (!used[i] && (v == -1 || min_e[i] < min_e)[v]):
			v = 1
	used[v] = true
	for (v, u) in E:
		min_e[u] = min(min_e[u], w(u, v))
```

Давайте переложим всё в какую-нибудь крутую кучу которая будет выдаватть минимальный, это ускорит нас до O(m+n log(n))


Алгоритм Крускала
sort всех ребер по весу, будет идти по ним и если не получается циклов, добавляем в ответ

```py
# Ребра уже отсортировали
for (u, v) in sorted_edges:
	if get(u) != get(v):
		unite(u, v)
```

Отсортируем за O(m log(m)), объеденим за O(m * \alpha(n))


Алгоритм Борувки
Для каждой вершины найдем минимальное ребро инцендентное ей
Возьмем ребро