# Недвудольные паросочетания
Увеличивающая цепь - это чередующая цепь, у которой первая и последняя вершины свободны от паросочетания

### Идея из двудольного случая
![[Pasted image 20251117121143.png]]
В двудольном случае мы хотели искать увеличивающие цепи, чтобы заменять их на большее паросочетание  

#### Теорема
Вспомним теорему, по которой в двудольном случае эквивалентны:
$$
M - \text{максимально} \iff \nexists \text{увелич. цепи}
$$
В её доказательстве не сильно использовалась двудольность, а чтобы она работала и в недвудольном случае нужно лишь рассмотреть случай с компонентами, имеющими вид нечетного цикла

С ними же у нас сразу возникнет проблема
![[Pasted image 20251117122104.png]]
Такого просто не может быть, так как мы рассматривали ребра принадлежащие либо $M$, либо $M'$, а в цикле нечетной длинны всегда будет оставаться ребро, которое мы не можем положить ни в одно из множеств

Из этого следует, что вышеупомянутая теорема работает и не в двудольном случае

### Попытка написать алгоритм
Теперь, как и в двудольном случае хочется просто написать *DFS*, который будет искать увеличивающие цепи
```py
# type - флаг, означающий тип реба, который мы хотим дальше
#   0 - не из М
#   1 - из M
	
dfs(v, type):
	used[v] = true
	
	# Проверим, нашли ли мы увеличивающую цепь
	if (type == 1 && free[v]):
		return true
	
	# Обходим дальше
	for (v, u) : g[v]:
		if (type == 0 && (v, u) not in M && !used[u]):
			dfs(u, 1)
		if (type == 1 && (v, u) in M && !used[u]):
			dfs(u, 0)
	return false
```
К сожалению такой код по идее должен работать, но не всегда сможет найти увеличивающую цепь

#### Контрпример
![[Pasted image 20251117123717.png]]
Как мы можем видеть, у нас есть хорошая увеличивающая цепь, однако если нам не повезет, то dfs её не найдет.
Там где на его пути будет развилка, если он пойдет не в ту сторону, что нам бы хотелось, то он просто пропустит цепь