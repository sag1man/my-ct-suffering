Стартовая вершина - исток: $(s)$
Конечная вершина - сток: $(t)$

Задача в том, чтобы распределить потоки, чтобы не привысить пропускные способности и чтобы максимизировать суммарный поток из истока в сток

Сеть - весь граф со всеми параметрами: $(G, s, t, c)$
$G$ - ор граф
$s, t \in V$
$c: V * V \rightarrow Z_+$

Поток $f: V * V \rightarrow Z_+$
$\forall (u, v) \in E: \quad 0 \leq f(u, v) \leq c(u, v)$
$\forall v \in V: \quad \sum_u$

Величина потока $|f| = \sum_v f(s, v) = \sum_u f(u, t)$
Мы хотим максимизировать $|f|$

Определим поток снова
$f: V * V \rightarrow R$
Хотим от потока 3 свойства
1) $\forall (u, v) \in V * V$
   $f(u, v) = -f(v, u)$
2) $\forall (u, v) \in V * V$
   $f(u, v) \leq c(u, v)$
3) $\forall v \in V \quad v \neq s, v \neq t$
   $\sum_u f(v, u) = 0$

Почему определения эквивалентны?
...

Теорема о декомпозиции потока
Есть некоторая сеть $(G, s, t, c)$, и поток $f$ в ней 

Тогда $f = f_1 + f_2 + ... + f_k$, где f_i выглядит так:


Найдем какой-то путь $s \rightarrow t$, где на каждом ребре $f > 0$
$f' = \min(f_1, f_2, ..., f_k)$

Разрез (S-T разрез)
$S \subset V, \quad s \in S$
$T = V \setminus S, \quad t \in T$

Величина разреза: $$c(S, T) = \sum_{u: u \in S} \sum_{v: v \in T} c(u, v)$$
Величина потока через разрез $(S, T)$: $$f(S, T) = \sum_{u: u \in S} \sum_{v: v \in T} f(u, v)$$

Лемма 1
Сеть (G, s, t, c), f - поток в ней
(S, T) - разрез

Тогда: f(S, T) = |f|

Лемма 2
Сеть (G, s, t, c), f - поток в ней
(S, T) - разрез

Тогда: |f| \leq c(S, T)
Следствие: $\max(|f|) \leq \min(c(S, T))$

Определение
Пусть сеть (G, s, t, c), f - поток в ней
G_g - остаточная сеть относительно потока f
c_f - остаточная пропускная способность
$\forall (u, v) c_f(u, v) = c(u, v) - f(u, v)$

Определение
Увеличивающий пусть относительно потока f - любой пусть в G_f, который ходит по ненулевым ребрам
...

Теорема Форда-Фалкерсона
Эквивалентны
1) f - максимальный
2) $\notexists$ ув. пути относительно $f$
3) $\exists (S, T)$ - разрез: $c(S, T) = |f|$

Алгоритм Форда-Фалкерсона
```
f = 0
while(true):
	Строим G_f 
	dfs(s) # Ищем увеличивющий путь в G_f
	if (Пути нет):
		break
	f' = min
	...
```
В худшем случае O((n + m) * |f|)