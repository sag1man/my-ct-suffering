Когда прерывание обрабатывается, оно это делает в обработчике и имеет свой контекскт

## Обработка прерываний
### Отложенная обработка прерываний
Отложенные действия при обработке прерываний, реализуюется с помощью callback (сохраняется указатель на функцию). Оно запускается уже после критичсеки-важной части обработки. 
Можно разделить на 2 типа:
- Те что исполняются в контексте обработчика
- Те что исполняются в контексте процесса
Во время обработки критически важной части прерывания, не обрабатываются другие прерывания, что негативно может влиять на систему.

### Soft IRQs (Мягкие прерывания)
- Исполяется в контекте прерывания
- Аллоцирован статически
- Может исполняться парарельно на нескольких ядрах
Механизм реализующий отложенные прерывания, которые исполняются в контексте обработчика

### Tasklets
- Исполняется в контексте прерывания
- Может быть аллоцирован динамически
- Исполняется последовательно

### Workqueues 
- Исполняется в контексте процесса

## Симметричное мультипроцессирование (SMP)
Подразумевается что есть процессор с несколькими ядрами, или несколько процессоров

Линукс поддерживает SMP и имеет набор механизмов чтобы процессы работали корректно, не сталкивайсь с гонкой

Гонка может произойти если:
- у нас есть 2 паралельных процесса, исполняющихся на разных ядрах цп
- они оба обращаются к общим ресурсам

Так как мы не знаем, как процесс исполняется, как им управляет пранировщик и тп, то они могут испортить друг другу общие ресурсы, из-за чего корректность работы алгоритмов сломается

### Как избежать гонки
- Найти опасное место в коде, где идет доступ к ресурсам, к которым может иметь доступ и другой процесс
- Использовать атомарные операции (atomic)
- Запретить вытеснение во время критической секции
- Сделать доступ к ресурсам последовательным

### Атомарные операции

### Spin locks
Очень просто API:
- spin_lock
- spin_unlock 

При блокировке мы просто ставим определенное поле в состояние блокировки, и если оно в таком состоянии, другие процессы не трогают критические ресурсы