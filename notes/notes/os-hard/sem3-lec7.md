# Управление памятью
## Линейное отображение памяти
0:00
## Произвольное отображение виртуальной памяти
2:50
Это когда непрерывным страницам в ВП сопостовляется фрагментированные страницы ФП. Или когда непоследовательным станицам ВП соответствуют последовательные физические.
Для этого есть несколько интерфейсов в ядре, которые позволяют производить аллокацию на уровне ядра:
- мульти-страничные устойчивые отображения (vmalloc, ioremap) - устойчивые в смысле что после отображения в ФП ими можно пользоваться достаточно долго)
- Временное отображение (atomic_kmap) - одностраничное и временное, в смысле что после отображения мы ей пользуемся только короткое количество времени (даже несколько секунд уже плохо кажется)
- Длительное одностраничное отображение (kmap) - просто отображение без атомарности (так что по хорошему нужно задуматься о механизмах синхронизации)

Мульти-страничные отображения позволяют отображать, при нем используется специальный механизм чтобы отлавливать выход за пределы этой памяти, для этого используется 2 виртуальные страницы, до и после отображения памяти, при попытке туда обратиться упадет page fault.

API который позволяет отображать произвольный набор физических страниц в непрерывные виртуальные это vmalloc/vfree(). 

API ioremap/iounmap() используется чтобы отображать память устройства или регистры устройства в виртуальное пространство ядра

## Фиксированное отображение линейных адрессов
11:45
Отображение вирутального пространства идет на фиксированные физические адреса. Так мы можем связаться с какими  то конкретными контроллерами или устройствами, например, APIC (Advanced Programmable Interrupt Controller). Если такое отображение есть, то нам надо знать базовый адрес, и смещения для разных регистров. Когда такое отображение используется, то на этапе компиляции резервируется базовый адре.

Для этого есть свой API:
- set_fixmap(idx, phys_addr) 
- set_fixmap_nocache(idx, phys_addr)

Разница в том, что в первом случае можно не обращать внимание на кэширование, а во втором мы явно используем некэширрованные 

## Временные отображения
14:30
Нужны чтобы отобразить одну страницу, быстро что-то сделать и сразу отпустить. Например это полезно в случае, когда мы обрабатываем прерывание, когда прерывание хочет очень быстро получить доступ к какой-то физической странице, быстро что-то делает и отпускать. Это удобно потому что не нужно использовать механизмы синхронизации и потому что можно избежать засорения TLB кэша. 

## Долговременные отображения
16:10
Для отображения страницы используется API kmap(), он должен быть использован вместе с kunmap()

```C
p2 = kmap(pages[0]);
/* do something with p2 here ... */
kunmap(p2);
```

- Разрешается переключение контекста
- Может быть использована только в своем контексте
- Одна специальная таблица ВП зарезервирована под долговременные отображения
- Есть специальный счетчик (page counter), который позволяет видеть статус страницы
	- `page counter == 0` - это означает, что страница не отображена и может быть использована.
	- Если `page counter == 1` - это означает, что страница не отображена, но может содержаться в TLB и должна быть вытеснена перед использованием.
	- Если `page counter == n` - это означает, что страница отображена `n - 1` раз.

## Управление физической памятью
19:40

Оно никак не зависит от механизмов управления виртуальной памятью. 
Управление физической памятью осуществляется с помощью специальной структуры данных `struct page` . 
Для каждой физической страницы есть запись запись в массиве `mem_map` .
В этих записях хранится счетчик сколько раз отображена страница, позиция странице в swap-разделе или файле , буферы для страницы, и другие данные.

## Зоны памяти
29:15
Физическая память делится на зоны (то есть не все адресса физической памяти равноправны)
- Zone DMA - первые 16MB ФП которые адресуются при помощь 24bit, она зарезервирована для отображения в неё физических устройств (при присоединении физического устройства резервируется определенный фрагмент памяти в DMA, так становится возможным общение с устройствам)
- Zone DMA32 - 4GB для общения с присоединяемыми устройствами, которые используются 32bit адрессацию. Это не обязательно 4GB, может быть и меньше выделенно
- Zone Normal - обычная зона, где лежат инструкции и данные процессов, так же используется ядром.
- Zone HiMem - исторический кусочек пришедший из 32bit систем, память которая не имеет перманентного отображения в ВП ядра. 
Есть в Linux системах утилита dmesg, которая показывает зонирование физической памяти.

