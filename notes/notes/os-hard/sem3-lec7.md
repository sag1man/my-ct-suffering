# Управление памятью
## Линейное отображение памяти
0:00
## Произвольное отображение виртуальной памяти
2:50

Это когда непрерывным страницам в ВП сопостовляется фрагментированные страницы ФП. Или когда непоследовательным станицам ВП соответствуют последовательные физические.
Для этого есть несколько интерфейсов в ядре, которые позволяют производить аллокацию на уровне ядра:
- мульти-страничные устойчивые отображения (vmalloc, ioremap) - устойчивые в смысле что после отображения в ФП ими можно пользоваться достаточно долго)
- Временное отображение (atomic_kmap) - одностраничное и временное, в смысле что после отображения мы ей пользуемся только короткое количество времени (даже несколько секунд уже плохо кажется)
- Длительное одностраничное отображение (kmap) - просто отображение без атомарности (так что по хорошему нужно задуматься о механизмах синхронизации)

Мульти-страничные отображения позволяют отображать, при нем используется специальный механизм чтобы отлавливать выход за пределы этой памяти, для этого используется 2 виртуальные страницы, до и после отображения памяти, при попытке туда обратиться упадет page fault.

API который позволяет отображать произвольный набор физических страниц в непрерывные виртуальные это vmalloc/vfree(). 

API ioremap/iounmap() используется чтобы отображать память устройства или регистры устройства в виртуальное пространство ядра

## Фиксированное отображение линейных адрессов
11:45
Отображение вирутального пространства идет на фиксированные физические адреса. Так мы можем связаться с какими  то конкретными контроллерами или устройствами, например, APIC (Advanced Programmable Interrupt Controller). Если такое отображение есть, то нам надо знать базовый адрес, и смещения для разных регистров. Когда такое отображение используется, то на этапе компиляции резервируется базовый адре.

Для этого есть свой API:
- set_fixmap(idx, phys_addr) 
- set_fixmap_nocache(idx, phys_addr)

Разница в том, что в первом случае можно не обращать внимание на кэширование, а во втором мы явно используем некэширрованные 

## Временные отображения
14:30
Нужны чтобы отобразить одну страницу, быстро что-то сделать и сразу отпустить. Например это полезно в случае, когда мы обрабатываем прерывание, когда прерывание хочет очень быстро получить доступ к какой-то физической странице, быстро что-то делает и отпускать. Это удобно потому что не нужно использовать механизмы синхронизации и потому что можно избежать засорения TLB кэша. 

## Долговременные отображения
16:10

Для отображения страницы используется API kmap(), он должен быть использован вместе с kunmap()

```C
p2 = kmap(pages[0]);
/* do something with p2 here ... */
kunmap(p2);
```

- Разрешается переключение контекста
- Может быть использована только в своем контексте
- Одна специальная таблица ВП зарезервирована под долговременные отображения
- Есть специальный счетчик (page counter), который позволяет видеть статус страницы
	- `page counter == 0` - это означает, что страница не отображена и может быть использована.
	- Если `page counter == 1` - это означает, что страница не отображена, но может содержаться в TLB и должна быть вытеснена перед использованием.
	- Если `page counter == n` - это означает, что страница отображена `n - 1` раз.

## Управление физической памятью
19:40

Оно никак не зависит от механизмов управления виртуальной памятью. 
Управление физической памятью осуществляется с помощью специальной структуры данных `struct page` . 
Для каждой физической страницы есть запись запись в массиве `mem_map` .
В этих записях хранится счетчик сколько раз отображена страница, позиция странице в swap-разделе или файле , буферы для страницы, и другие данные.

## Зоны памяти
29:15

Физическая память делится на зоны (то есть не все адресса физической памяти равноправны)

- Zone DMA - первые 16MB ФП которые адресуются при помощь 24bit, она зарезервирована для отображения в неё физических устройств (при присоединении физического устройства резервируется определенный фрагмент памяти в DMA, так становится возможным общение с устройствам)
- Zone DMA32 - 4GB для общения с присоединяемыми устройствами, которые используются 32bit адрессацию. Это не обязательно 4GB, может быть и меньше выделенно
- Zone Normal - обычная зона, где лежат инструкции и данные процессов, так же используется ядром.
- Zone HiMem - исторический кусочек пришедший из 32bit систем, память которая не имеет перманентного отображения в ВП ядра. 

Есть в Linux системах утилита dmesg, которая показывает зонирование физической памяти.

## Non-Uniform Memory Access (NUMA) & UMA
6:20

Если у нас есть несколько ядер, то появляется вопрос как иметь быстрый доступ к памяти, если не хотим проблем с синхронизацией.
Представим что у нас 4 ядра, тогда поделим физическую память на равные части и отдадим соответствующим ядрам. Так ядро будет иметь доступ к своей памяти без необходимости синхронизации, однако если процесс попробует получить доступ к памяти другого ядра, то тогда включится синхронизация.

- Non-Uniform означает что память неоднородна, то есть есть "своя" память, а есть "чужая", к своей будет быстрый доступ, а к чужой долгий из-за надобности синхронизации.
- Uniform режим как раз означает что память однородна, но тогда синхронизация необходима всегда, и доступ медленнее.

В случае NUMA есть в Linux специальная структура, которая хранит информацию о разбиении физической памяти на "куски", каждый "кусок" является независимым и сам хранит информацию о зонировании, информацию о свободных и занятых страницах и другие системные счетчики

## Кэш страницы
11:44

Поскольку физическая память переиспользуется и в большинстве устройств не хранит содержимое при отсутствии питания, в операционной системе есть специальный механизм кэширования страниц. 

Он используется чтобы сделать чтение/запись файла кэшированным, то есть когда мы читаем из файла, то мы читаем сразу страницами, и если понадобятся данные рядом с уде прочитанными, то они уже будут в оперативной памяти. С записью процесс аналогичный.

Записанные страницы помечаются как грязные и когда Linux решает использовать их повторно для других целей, он обеспечивает синхронизацию содержимого файла на устройстве.

## Аллокация физических страниц 
19:10

Прежде чем отобразить физические страницы в виртуальное пространство, их надо где-то взять. Для этого существует специальный API alloc_pages, который позволяет получить какое-то количество физических страниц, но это всегда степень двойки. Он возвращает 

### Почему всегда выделяется степень двойки?
20:55

Это реализовано так, чтобы уменьшить сложность алгоритмов выделения памяти

### Реализация buddy в Linux
22:10

### Slab аллокатор
23:10

### Why SLAB
28:30

### SLAB Architecture
2:15

### SLAB allocator implementation
5:15

### Cache descriptor
9:30

### Slab descriptors and generic caches
11:00

### Object descriptors
15:50

### Cache coloring of slabs
16:55

23 - конец
