## Page faults (продолжение)
### Типы page fault
#### Minor page fault
- Случай 1
	- Страница уже загружена в память на момент возникновения *page fault*, но не помечена как загруженная в *MMU*
	- Обработчик *page fault* обновляет таблицы *MMU*, чтобы они указывали на эту страницу
	- Так происходит, если страница разделялась несколькими процессами и уже была загружена ранее другим процессом
- Случай 2
	- Страница была удалена из рабочего набора процесса, но не была ни записана на диск, ни стерта (чистые страницы просто отбрасываются, не записываясь на диск)
	- Однако содержимое страницы не перезаписывается, пока страница не будет выделена под что-то другое, поэтому она всё ещё будет доступна, если 

#### Major page fault
- Происходит когда станица не загружена в память на момент возникновения *page fault*
- Это механизм, который используется ОС для увеличения объема доступной программе памяти по запросу.
- ОС откладывает загрузку частей программы с диска до момента, пока программа не попробует их использовать, и тогда возникнет *page fault*
- Обработчик *page fault* должен найти свободную физическую страницу:
	- Либо уже свободную страницу в памяти
	- Либо придется использовать занятую страницу:
	  Занятая страница может использоваться другим процессом, тогда нужно выгрузить её на диск (если она менялась после последней записи) и пометить как "не загруженную" в таблице страниц процесса 
- Когда уже доступна свободная страница
	- ОС считывает нужные данные в память
	- Добавляет запись о её расположении в таблицы *MMU*
	- Помечает страницу как загруженную
- *Major page fault* дороже чем *minor page fault*, так как требует задержку прерывания процесса на доступ к диску

#### Invalid page fault
- Если *page fault* возникает при обращении к адресу, который не входит в виртуальное пространство процесса (следовательно, если не может соответствовать никакая страница в памяти), то такое событие называется *invalid page fault*
- Обработчик *page fault* в такое случае обычно посылает процессу исключение *segmentation fault*, указывая что доступ в память был недопустим
- Обычно это приводит к аварийному завершению кода, который сделал неправильное обращение
- Нулевой указатель, как правило, представляется как указатель на адрес `0` в адресном пространстве
	- ОС настраивает таблицы трансляции *MMU* так, чтобы указывать, что страница, содержащая этот адрес, отсутствует в памяти
    - Любая попытка чтения или записи по адресу, на который указывает нулевой указатель, приводит к *invalid page fault*

### Влияние page fault на производительность
- *Major page faults* на компьютерах с жёсткими дисками существенно снижают производительность
- HDD всё ещё популярны из-за более высокой надежности и износостойкости относительно SSD
- Средний HDD имеет
    - Среднюю задержку вращения 3мс
    - Время поиска дорожки 5мс
    - Время передачи 0,05мс на страницу
- Поэтому общее время подкачки около 8мс
    - **CAS-задержка** - это задержка в тактах между командой на чтение и моментом, когда данные (первое слово) становятся доступными
    - Для DDR3-1066 CL = 7 тактов (1 такт = 1,875 нс)
    - Для DDR4-1600 CL = 12 тактов (1 такт = 1,250 нс)
- Оптимизация производительности программ и ОС часто сводится к уменьшению числа *page fault*
- Основные направления оптимизации: 
	- Уменьшение общего объёма потребляемой памяти
	- Улучшение локальности обращений к памяти
- Чтобы уменьшить число *page fault*, нужно выбирать подходящий алгоритм замещения страниц, который максимизирует *page hits* (попадания в страницы в память)
- Увеличение объёма физической памяти также уменьшает количество *page fault*

---
## Абстракции файловой системы
- **Superblock** (суперблок) - содержит информацию о конкретном экземпляре файловой системы: размер блока, *root-inode*, общий размер файловой системы. Он есть и на носителе, и в памяти (для кеширования)
- **File** (абстракция файла) содержит информацию об открытом файле, например текущий указатель чтения/записи, содержится только в памяти
- **Inode** идентифицирует файл на диске - однозначно задаёт файл и хранит его свойства: размер, права доступа, тип файла и т.д. Существует и на носителе, и в памяти (для кеширования)
- **Dentry** (*directory entry*) связывает путь/имя файла с *inode*. Существует и на носителе, и в памяти (для кеширования)

### Абстракции файловой системы в памяти
![[Pasted image 20251112015113.png]]
- Файловый дескриптор по факту просто индекс в таблице файловых дескрипторов
- Из таблицы записи уже указывают на *file* объекты
- Несколько файловых дескрипторов могут указывать на один и тот же файл, так как есть системный вызов `dup()` позволяющий дублировать дескриптор
- Несколько объектов *file* могут указывать на один и тот же *dentry*, если мы многократно открываем один и тот же путь
- Несколько *dentry* могут указывать на один и тот же *inode*, когда используются жёсткие ссылки (*hard links*)

### Абстракции файловой системы на носителе (диске)
![[Pasted image 20251112015806.png]]
- Носитель сам по себе представляет последовательность блоков
- *Superblock* обычно хранится в начале файловой системы
- Разные блоки диска используются для разных целей:
	- Часть блоков хранит *dentry*
	- Часть блоков хранит *inode*, а часть — пользовательские данные (*data blocks*)
	- Некоторые блоки используются для управления свободными блоками

### Операции файловой системы
![[Pasted image 20251112020300.png]]
- Высокоуровневое представление того, как драйверы файловых систем взаимодействуют с остальной частью стека файловой системы
- Чтобы поддерживать несколько типов и экземпляров файловых систем, *Linux* реализует большую и сложную подсистему, которая занимается управлением файловыми системами 
- Она называется **Virtual File System / Switch (VFS)** - виртуальная файловая система /переключатель
- Все ФС верхнего уровня работают с устройствами не напрямую, а через *VFS* 
- *VFS* переводит сложные системные вызовы, связанные с управлением файлами, в более простые операции, которые реализуются драйверами устройств
- Операции, которые должна поддерживать файловая система:
	- Монтирование ФС
	- Открытие файла
	- Обработка атрибутов файла
	- Чтение данных из файла
	- Запись данных в файл
	- Создание файла
	- Удаление файла
	- и т.д.

#### Монтирование файловой системы
- Ввод: носитель (точнее его раздел)
- Вывод: dentry`, указывающий на корневой каталог.
- **Шаги:**
  - проверить устройство;
  - определить параметры файловой системы;
  - найти корневой inode.
- **Пример:**
  - проверить *magic*;
  - определить размер блока;
  - прочитать корневой inode и создать `dentry`

#### Открытие файла
- Вход: путь к файлу
- Выход: дескриптор файла
- Шаги:
  - Определить тип файловой системы
  - Для каждого имени в пути:
    - Найти родительский *dentry*
    - Загрузить *inode*
    - Загрузить данные
    - Найти *dentry*
  - Создать новый объект *file*, указывающий на последний *dentry*
  - Найти свободную запись в таблице дескрипторов и установить её на *file*

#### Запрос атрибутов файла
- Ввод: путь к файлу
- Вывод: атрибуты файла
- Шаги:
  - Идем по цепочке `file` -> `dentry` -> `inode`
  - Прочитать атрибуты из `inode`

#### Чтение данных из файла
- Вход: дескриптор файла, смещение, длина
- Выход: данные файла
- Шаги:
  - пройти по цепочке `file` → `dentry` → `inode`
  - определить необходимые блоки данных
  - скопировать блоки данных в память
  
- #### Запись данных в файл
- Вход: дескриптор файла, смещение, длина, данные
- Выход: флаг успешности операции
- Шаги:
  - Выделить один или несколько блоков данных
  - Добавить выделенные блоки в *inode* и обновить размер файла
  - Скопировать данные из пространства пользователя во внутренние буферы и записать их на носитель

#### Закрытие файла
- Ввод: дескриптор файла
- Вывод: 
- Шаги:
  - Установить запись дескриптора файла в `NULL`
  - Декрементировать счётчик ссылок `file`
  - Когда счётчик достигает 0 — освободить `file`

#### Каталоги
- Это специальные файлы, содержащие один или несколько *dentry*

##### Создание файла:
- Вход: путь
- Выход:
- Шаги:
	- Определить *inode* каталога
    - Прочитать блоки данных каталога и найти место для нового *dentry*
    - Записать на диск модифицированные блоки данных каталога (с новым *dentry*)

##### Удаление файла:
- Вход: путь
- Выход:
- Шаги:
    - Определить родительский *inode*
    - Прочитать блоки данных родительского *inode*
    - Найти и удалить соответствующий *dentry* (проверить количество жёстких ссылок)
    - Когда последний открытый дескриптор закрыт - освободить блоки данных и *inode*

## Виртуальная файловая система (VFS)
- Основная цель появления *VFS* - поддерживать несколько типов и экземпляров файловых систем одновременно
- Побочный эффект - упростилась разработка драйверов ФС, потому что общие части логики вынесены в *VFS*
- Почти всё кеширование и управление буферами делает VFS; драйвер конкретной файловой системы отвечает в основном за **эффективное размещение данных на носителе**.
- Чтобы работать с разными ФС, VFS вводит общие абстракции (*inode*, *dentry*, *file* и т.п.) - они единые для ядра.
- Драйвер ФС может использовать свои собственные структуры в памяти (например, inode/dentry формата ext4), а на диске могут лежать ещё другие структуры.
    
- В итоге есть три близких, но разных набора абстракций:
	- абстракции **VFS** — всегда в памяти, общие для всех ФС
    - абстракции **конкретной файловой системы** в памяти (используются драйвером ФС)
    - структуры **на диске** (формат данных конкретной ФС)