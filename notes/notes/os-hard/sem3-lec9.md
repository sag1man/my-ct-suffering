## Page faults (продолжение)
### Типы page fault
#### Minor page fault
- Случай 1
	- Страница уже загружена в память на момент возникновения *page fault*, но не помечена как загруженная в *MMU*
	- Обработчик *page fault* обновляет таблицы *MMU*, чтобы они указывали на эту страницу
	- Так происходит, если страница разделялась несколькими процессами и уже была загружена ранее другим процессом
- Случай 2
	- Страница была удалена из рабочего набора процесса, но не была ни записана на диск, ни стерта (чистые страницы просто отбрасываются, не записываясь на диск)
	- Однако содержимое страницы не перезаписывается, пока страница не будет выделена под что-то другое, поэтому она всё ещё будет доступна, если 

#### Major page fault
- Происходит когда станица не загружена в память на момент возникновения *page fault*
- Это механизм, который используется ОС для увеличения объема доступной программе памяти по запросу.
- ОС откладывает загрузку частей программы с диска до момента, пока программа не попробует их использовать, и тогда возникнет *page fault*
- Обработчик *page fault* должен найти свободное место:
	- Либо свободную страницу в памяти
	- Либо придется использовать занятую страницу:
	  Занятая страница может использоваться другим процессом, тогда нужно выгрузить её на диск (если она менялась после последней записи) и пометить как "не загруженную" в таблице страниц процесса 
- Когда уже доступна свободная страница
	- ОС считывает нужные данные в память
	- Добавляет запись о её расположении в таблицы *MMU*
	- Помечает страницу как загруженную
- *Major page fault* дороже чем *minor page fault*, так как требует задержку прерывания процесса на доступ к диску

#### Invalid page fault
- Если *page fault* возникает при обращении к адресу, который не входит в виртуальное пространство процесса (следовательно, если не может соответствовать никакая страница в памяти), то такое событие называется *invalid page fault*
- Обработчик *page fault* в такое случае обычно посылает процессу исключение *segmentation fault*, указывая что доступ в память был недопустим
- Обычно это приводит к аварийному завершению кода, который сделал неправильное обращение
- Нулевой указатель, как правило, представляется как указатель на адрес `0` в адресном пространстве
	- ОС настраивает таблицы трансляции *MMU* так, чтобы указывать, что страница содержащая этот адрес, отсутствует в памяти
    - Любая попытка чтения или записи по адресу, на который указывает нулевой указатель, приводит к *invalid page fault*

### Влияние page fault на производительность
- *Major page faults* на обычных компьютерах с жёсткими дисками существенно снижают производительность
- Средний жёсткий диск имеет
    - Среднюю задержку вращения 3мс
    - Время поиска дорожки 5мс
    - Время передачи 0,05мс на страницу
- Поэтому общее время подкачки около 8мс
    - **CAS-задержка** - это задержка в тактах между командой на чтение и моментом, когда данные (первое слово) становятся доступными
    - Для DDR3-1066 CL = 7 тактов (1 такт = 1,875 нс)
    - Для DDR4-1600 CL = 12 тактов (1 такт = 1,250 нс)
- Оптимизация производительности программ и ОС часто сводится к уменьшению числа *page fault*
- Основные направления оптимизации: 
	- Уменьшение общего объёма потребляемой памяти
	- Улучшение локальности обращений к памяти.
- Чтобы уменьшить число *page fault*, нужно выбирать подходящий алгоритм замещения страниц, который максимизирует *page hits* (попадания в страницы в память)
- Увеличение объёма физической памяти также уменьшает количество *page fault*

---
## Абстракции файловой системы
- **Superblock** (суперблок) - содержит информацию о конкретном экземпляре файловой системы: размер блока, *root-inode*, общий размер файловой системы. Он есть и на носителе, и в памяти (для кеширования)
- **File** (абстракция файла) содержит информацию об открытом файле, например текущий указатель чтения/записи, содержится только в памяти
- **Inode** идентифицирует файл на диске - однозначно задаёт файл и хранит его свойства: размер, права доступа, тип файла и т.д. Существует и на носителе, и в памяти (для кеширования)
- **Dentry** (*directory entry*) связывает путь/имя файла с *inode*. Существует и на носителе, и в памяти (для кеширования)

### Абстракции файловой системы в памяти
![[Pasted image 20251112015113.png]]
- Несколько файловых дескрипторов могут указывать на один и тот же файл, так как есть системный вызов `dup()` позволяющий дублировать дескриптор
- Несколько объектов *file* могут указывать на один и тот же *dentry*, если мы многократно открываем один и тот же путь
- Несколько *dentry* могут указывать на один и тот же *inode*, когда используются жёсткие ссылки (*hard links*)

### Абстракции файловой системы на носителе (диске)
![[Pasted image 20251112015806.png]]
- *Superblock* обычно хранится в начале файловой системы
- Разные блоки диска используются для разных целей:
	- Часть блоков хранит *dentry*
	- Часть блоков хранит *inode*, а часть — пользовательские данные (*data blocks*)
	- Некоторые блоки используются для управления свободными блоками

### Операции файловой системы
![[Pasted image 20251112020300.png]]
- Высокоуровневое представление того, как драйверы файловых систем взаимодействуют с остальной частью стека файловой системы
- Чтобы поддерживать несколько типов и экземпляров файловых систем, *Linux* реализует большую и сложную подсистему, которая занимается управлением файловыми системами 
- Она называется **Virtual File System / Switch (VFS)** - виртуальная файловая система /переключатель
- *VFS* переводит сложные системные вызовы, связанные с управлением файлами, в более простые операции, которые реализуются драйверами устройств
- Операции, которые должна поддерживать файловая система:
	- Монтирование ФС
	- Открытие файла
	- Обработка атрибутов файла
	- Чтение данных из файла
	- Запись данных в файл
	- Создание файла
	- Удаление файла
	- и т.д.
