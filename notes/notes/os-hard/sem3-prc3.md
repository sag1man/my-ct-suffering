
---

[Конспекты](/index.md) / [Операционные системы (hard)](/notes/os-hard/index.md) / [Практика 3 - Copy-on-write fork](/notes/os-hard/sem3-prc3.md)

---

# Copy-on-write fork
## fork() 
### Вспомним что это такое
- `fork()` - этот системный вызов для создания копии процесса
- Копия получит то же содержимое памяти, контекст, и продолжит с того же места
- В Unix это единственный способ создания нового процесса

### Как им пользоваться
Всё очень просто:
```C
int result = fork();

if (result == 0) {
	// It's a child
} else {
	// It's a parent
}
```

### Запуск другого процесса
Часто мы используем `fork()` чтобы запустить другой процесс. 
Для этого после `fork()` мы вызываем `exec()` / `execve()`, он заменяет текущий процесс на переданный в `exec()`, начиная исполнение с точки входа.

### В чем проблема
Очевидная проблема - `fork()` копирует весь процесс. 
- Если мы после этого сделали `exec()`, то предыдущие данные нам вообще не нужны.
- Если `exec()` не делаем, то всё равно очень большое количество данных переиспользуется для чтения, но они не меняются новым процессом.

## Виртуальная память
### Концепция виртуальной памяти
- Виртуальная память позволяет нам создать некоторую абстракцию последовательности памяти
- Представляет из себя структуру данных, состоящую из таблиц, которая может маппить виртуальные адреса в физические

### Детали реализации
- У каждого процесса в в специальном регистре лежит указатель на самую первую страницу таблицы виртуальной памяти, например в Risk-V он называется `satp`
- Сам процесс не имеет доступа к таблице виртуальной памяти - он оперирует только виртуальными адресами, и как они маппятся в физические ему знать не надо
- Идея в том, чтобы делить виртуальный адрес на группы битов, отвечающих на смещение внутри таблиц

![Виртуальная память](/pictures/os-hard-sem3-prc3-img1.png)  

### Довыделение памяти
Системный вызов `sbrk()` маппит виртуальные адреса из кучи на физические (мы говорим ему сколько нам надо добавить байт, он берет страницы и маппит, чтобы они выглядели последовательно для пользователя)
 
## Copy-on-write
##### Идея
- Оба процесса делят между собой общие физические страницы
- Если кто-то из процессов пишет в страницу - сделаем её копию и будем писать туда





Как нам понять, что в user-space кто-то попытался записать в память? Нам помогут прерывания. 
- Внешние прерывания - прерывания от переферийных устройств.
- Внутренние прерывания - генерирует сам процессор, например:
	- Проблемы с выполнением инструкции (деление на ноль)
	- Проблема с доступом к памяти (page fault)
	- Специальные инструкции для прерывания 


