
---

[[index|Конспекты]] / [[notes/os-hard/index|Операционные системы (hard)]] / РАЗДЕЛ НЕ ГОТОВ

---

# Copy-on-write fork
## fork() 
### Вспомним что это такое
- fork() - этот системный вызов для создания копии процесса
- Копия получит то же содержимое памяти, контекст, и продолжит с того же места
- В Unix это единственный способ создания нового процесса

### Как им пользоваться
Всё очень просто:
```C
int result = fork();

if (result == 0) {
	// It's a child
} else {
	// It's a parent
}
```

### Запуск другого процесса
Часто мы используем fork() чтобы запустить другой процесс. 
Для этого после fork() мы вызываем exec() / execve(), он заменяет текущий процесс на переданный в exec(), начиная исполнение с точки входа.

### В чем проблема
Очевидная проблема - fork() копирует весь процесс. 
- Если мы после этого сделали exec(), то предыдущие данные нам вообще не нужны.
- Если exec() не делаем, то всё равно очень большое количество данных переиспользуется для чтения, но они не меняются новым процессом.

## Copy-on-write
##### Идея
- Оба процесса делят между собой общие физические страницы
- Если кто-то пишет в них - сделаем копию страницы  и будем писать туда

Системный вызов sbrk() маппит виртуальные адресса из кучи на физические (мы говорим ему сколько нам надо добавить байт, он берет страницы и маппит, чтобы они выглядели последовательно для прользователя)

Как нам понять, что в user-space кто-то попытался записать в память? Нам помогут прерывания. 
- Внешние прерывания - прерывания от переферийных устройств.
- Внутренние прерывания - генерирует сам процессор, например:
	- Проблемы с выполнением инструкции (деление на ноль)
	- Проблема с доступом к памяти (page fault)
	- Специальные инструкции для прерывания 


